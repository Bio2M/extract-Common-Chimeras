#! /usr/bin/perl
## author: Nicolas PHILIPPE, AL BOUGE, Chloe BESSIERE
## email: chloe.bessiere@inserm.fr
## goal: extract common chimeras detected after the chimeraPipeline process of chimCT (crac-tools)

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use CracTools::Output;
use Data::Dumper;

use constant VERSION 		  => "2.0.0-chloe";
use constant MAX_PRINT_NAME       => 10;
use constant MAX_PRINT_REDUNDANCY => 45;
use constant NA                   => "N/A";

=head1 NAME

    extractCommonChimeras.pl - Extract common chimeras from a list of csv files generated by chimCT (crac-tools). By default, we only consider redundant chimeras, found in at least 2 different samples, but the threshold can be modified.

=head1 SYNOPSIS

    extractCommonChimeras.pl [-h] [-v] [--min-ranking <score>] [--threshold <min_redundancy>] [--min-cover <min_coverage>] [--summary <output_file>] [--output <output_file>] [--Rdata <output_file>] [--filter <filter_file>] <file1.csv> <file2.csv> ... <filen.csv>

    Mandatory: at least two csv files (generated by the chimera pipeline).

 --output        filename to write the results (default: stdout)
 --min-ranking   minimal rank (score between 0 and 100) to consider the
                 chimera (50 by default)
 --threshold     minimal redundancy to consider a redundant chimera,
                 i.e. the min number of different samples where a same
                 chimera is found (2 by default)
 --min-cover     minimal span junction raw reads number (default: 1)
 --summary       make some statistics in the output_file if the argument
                 is defined
 --Rdata         format the statistics for R graphics in the output_file
                 if the argument is defined
 --filter        a file containing chimeras id (one name by line) to be
                 filtered-out (chimeras black list)
 -h --help       output this help and exit
 -v --version    output version information and exit

=head1 OPTIONS

    -h, --help
    -v, --version
    --min-ranking=I<score>
    --threshold=I<min_redundancy>
    --min-cover=I<min_coverage>
    --summary=I<output_FILE>
    --Rdata=I<output_FILE>

=head1 OUTPUT FORMAT

This is a descrition of the fields of the output file format. Each line corresponds to a redundant chimera
identified and annotated by the chimeraPipeline. Chimeras are ordered by Score, Class and number of
redundant chimeras.

=over

=item 1  B<Id>                 - A Uniq Id for each chimera.

=item 2  B<name>               - Fusion gene names (symbols) separated by three dashes ('---')

=item 3  B<samples>            - List of samples containing this chimera.

=item 4  B<class>              - Chimeric class from 1 to 4.

=item 5  B<subclass>           - Subclass inference. Example: overlap, short_distance, etc.

=item 6  B<mean_score>         - Mean score of the chimera across <samples> (between 0 and 100).
                                 The rank is based on confidence about chimera's positivity.

=item 7  B<count>              - It correponds to the number of different sample where the chimera is found.

=item 8  B<comments>           - Several comments about the chimera and the rank computed.

=item 9 B<read_seq>            - Sequence of a read containing this chimera junction.

=item 10 B<pos_junction>       - Position of the chimeric junction in the read.

=item 11 B<profil_support>     - Support profile

=item 12 B<profil_location>    - Location profile 

=back

=head1 DESCRIPTION

    This script can be used to filter and group redondant chimeras between different samples and conditions.

=head1 REQUIRES

    Perl5.
    Getopt::Long
    Pod::Usage

=head1 AUTHOR

    Nicolas PHILIPPE, AL BOUGE, Chloe BESSIERE <chloe.bessiere@inserm.fr>

=cut

#=item 3  B<Chr1>               - Chromosome of the 5' part of the chimera
#=item 4  B<Pos1>               - Genomic positions of the 5' part of the chimera
#=item 5  B<Strand1>            - Genomic strand of the 5' part of the chimera. If sample is not C<--stranded>
#                              No assumption can be made about the strand
#=item 6  B<Chr2>               - Chromosome of the 3' part of the chimera. Same as I<Chr2>, unless it is a class 1 chimera (translocation).
#=item 7  B<Pos2>               - Genomic positions of the 3' part of the chimera
#=item 8  B<Strand2>            - Genomic strand of the 3' part of the chimera. If sample is not C<--stranded>
#                              No assumption can be made about the strand
#=item 12 B<Listof (Sample,Spanning_junction,Spanning_PE,Rank)>
#                               - Sample identified the experiment
#                                 Spanning junction read that contains the chimeric junction
#                                 Spanning paired-end reads that contains the chimeric junction but in the non-sequenced part
#                                 Rank computed by the chimeraPipeline for the chimera in that Sample


my ($help, $version, $min_score, $min_cover, $max_cover, $summary_file, $min_redundant, $max_redundant, $output_file, $r_file, $filter_file) = (0, 0, 50, 1, undef, undef, 2, undef, undef, undef, undef);

GetOptions( 	"min-ranking=i" => \$min_score, # score between 0 and 100
		"min-cover=i"   => \$min_cover, # raw spanning junction reads ?
		"threshold=i"   => \$min_redundant, # minimal redundancy to keep a chimera
		"max-cover=i"   => \$max_cover,
		"summary=s"     => \$summary_file,
		"max-redund=i"  => \$max_redundant, # not defined ?
		"output=s"      => \$output_file,
		"Rdata=s"       => \$r_file,
		"filter=s"      => \$filter_file,
		"help"          => \$help,
		"version"       => \$version,
        ) or pod2usage(-verbose => 0);

pod2usage(-verbose => 0)  if ($help);
if ($version) {
    print VERSION."\n";
    exit 0;
}
if (scalar @ARGV < 2){
    pod2usage(-verbose => 0);
    exit 1;
}

# % for hash variables (key/value)

my %hash;
my %hashsample;
my $nb_sample = 0;
my $filter = 0;
my $nb_filtered_chim = 0;
my $samples;
my $total_chim = 0;
my $nb_low_spanj = 0;
my $total_chimIds = 0;
#my $total_redund_chim = 1;
my $nb_commented_chim = 0;
my $absSpanJ_thr = $min_cover;

# If there is a filter file, create a hash to filter-out these chimeras

my %filter_chimeras;
if(defined $filter_file){
	open(IN,$filter_file) or die("Cannot open $filter_file");
	while(<IN>) {
		next if $_ =~ /^#/;
		chomp;
		if ($_ =~ /^\S+:(\S+)/){
			$filter_chimeras{$1}++;
		}
	}
	close IN;
}

# Store info for recurrent chimeras (sample by sample, reading chimCT input files one by one)

print "Storing chimeras informations...\n";

while (my $file = shift @ARGV){
	open(IN,$file) or die("enable to open $file");
    my $new_sample = 1;
    my ($sample, $analysed, $span_j, $span_PE);
    while(<IN>){
		chomp;	# This function delete the last line break at the end of the string
		# store sample features contained into the header (comments)
		if (($new_sample==1) && ($_ =~ /^#/)){ # reading new sample + comments lines (/^#/ equals comments lines)
			if (/Args.*(?:-n|--sample)\s+(\S+)/){ # finding and extracting sample name in chimCT input file ( Args: ... -n SAMPLE-NAME ...)
				$sample = $1;
				$nb_sample++;
			}
			if (/Nb\s+total\s+of\s+reads.*\D+(\d+)$/){ # finding and extracting sample nb total of reads in chimCT input file (# Nb total of reads: NB)
				$hashsample{$sample}{'SAMPLE_COUNTS'}{'SAMPLE_READS'} = $1;
			}
			if (/Nb\s+chimeras.*\D+(\d+)$/){ # finding and extracting sample nb total of chimeras in chimCT input file (# Nb chimeras: NB)
				$hashsample{$sample}{'SAMPLE_COUNTS'}{'SAMPLE_CHIMERA'} = $1;
			}
			if (/Nb\s+spanning\s+junction.*\D+(\d+)$/){ # finding and extracting sample nb of spanning junction reads in chimCT input file (# Nb spanning junction reads: NB)
				$span_j = $1;
				$hashsample{$sample}{'SAMPLE_COUNTS'}{'SAMPLE_SPANJ'} = $span_j;
			}
			if (/Nb\s+spanning\s+PE.*\D+(\d+)$/){ # finding and extracting sample nb of spanning PE reads in chimCT input file (# Nb spanning PE reads: NB)
				$span_PE = $1;
				$hashsample{$sample}{'SAMPLE_COUNTS'}{'SAMPLE_SPANPE'} = $span_PE;
			}
		}
		elsif (($new_sample==1) && ($_ !~ /^#/)) { 	# reading new sample + not a comment line (if not a comment)
			my ($ids,$name,$chr1,$pos1,$strand1,$chr2,$pos2,$strand2,$score,$spanJ,$spanPE,$class,$comments,$mrnaIDs,$annot,$desc,$exonIDs,$exonDist,$exonRank,$readID,$posJ,$readSeq,$support,$loc,$nbSpanR,$nbSpanPE,@others) = split(/\t/,$_);
			my ($sample,$id) = split(/:/,$ids);
			my ($trash_span, $absSpanJ) = split(/=/,$nbSpanR);
			my ($trash_dist,$dist) = split(/=/,$exonDist);
			my ($ex1End,$ex2End)= split(/---/,$dist);
			my $subclass;
			if (defined $id){
				# do not store chimeras if absolute spanj < x reads (default = 1)
				if ($absSpanJ < $absSpanJ_thr){
					$nb_low_spanj++;
					next;
				}
				# Filter chimeras : do not store chimera if it belongs to filtered chimeras list (black list)
				if (defined $filter_chimeras{$id}){
        	      $nb_filtered_chim++;
        	      next;
				}
				# counting comments for a same chimera + do not store chi
				if (defined $comments){
					my $pseudogene = 0;
					my $anchored = 0;
					my $strange = 0;
					my $GSNAP = 0;
					my @comments_tmp = split(/,/,$comments);
					foreach my $comment (@comments_tmp){
						if ($comment =~ /.*pseudogene/){
							$nb_commented_chim++;
							$pseudogene++;
							last;
						}elsif (($comment =~ /.*anchored/) && ($absSpanJ > 10)) {
							$nb_commented_chim++;
							$anchored++;
							last;
						}elsif (($comment =~ /.*PairedEndChimeras=strange_paired_end_support.*/)) {
							$nb_commented_chim++;
							$strange++;
							last;
						}elsif (($comment =~ /.*GSNAPMapping.*/)) {
							$nb_commented_chim++;
							$GSNAP++;
							last;
						}
					}
					next if (($pseudogene>0) || ($anchored>0) || ($strange>0) || ($GSNAP>0));
				}
				# annotate chimera subclasses
				if (($class==1) && (("$ex1End" ne "N/A") && ("$ex2End" ne "N/A"))) {
					if (($ex1End<5) && ($ex2End<5)) { # end exons distance < 5
						$subclass = "exon_borders";
					}
				}elsif (($class==2) && (abs($pos2 - $pos1)<1000000)){ # class2 + distance < 1 million => readthrough
					$subclass = "potential_readthrough";
				}elsif ($class == 3) {
					my @comments_temp = split(/,/,$comments);
					foreach my $comment (@comments_temp){
						if ($comment =~ /FusionDistance=([^0-9(]+)/){
							$subclass = $1;
						}
					}
				}elsif (($class == 4) && (($pos2-$pos1) <= 0)){
					$subclass = "overlap";
				}
				# store features by chimera	: if chimera doesn't exist
				if (!defined $hash{$id}){
					$hash{$id}{'NAME'} = $name;
					$hash{$id}{'CLASS'} = $class;
					$hash{$id}{'SUBCLASS'} = $subclass;
					$hash{$id}{$sample}{'SPANJ'} = $spanJ;
					$hash{$id}{$sample}{'SPANPE'} = $spanPE;
					$hash{$id}{$sample}{'COVER'} = ($spanPE + $spanJ);
					$hash{$id}{$sample}{'SCORE'} = $score;
					$hash{$id}{'FEATURES'} = $ids."\t".$name."\t".$chr1."\t".$pos1."\t".$strand1."\t".$chr2."\t".$pos2."\t".$strand2;
					$hash{$id}{'OTHERS'} = \@others;
					$hash{$id}{'SUM_SCORE'} = $score;
					$hash{$id}{'COUNT'} = 1;
					$hash{$id}{'POS_JUNCTION'} = $posJ;
					$hash{$id}{'READ'} = $readSeq;
					$hash{$id}{'PSUP'} = $support; # keeping the first profil support for one chimera
					$hash{$id}{'PLOC'} = $loc; # keeping the first profil location for one chimera
					$hash{$id}{'SAMPLES'} .= "$sample";
					$total_chimIds++;
				# If chimera exists
				}else{
					# in the same sample : keeping the one with higher spanning junction
					if (defined $hash{$id}{$sample}){
						next if ($hash{$id}{$sample}{'SPANJ'} > $spanJ);
						$hash{$id}{$sample}{'SPANJ'} = $spanJ;
						$hash{$id}{$sample}{'SPANPE'} = $spanPE;
						$hash{$id}{$sample}{'COVER'} = ($spanPE + $spanJ);
						$hash{$id}{$sample}{'SCORE'} = $score;
						$hash{$id}{'SUM_SCORE'} = $score;
					# if chimera exists but in a different sample
					}else{	# creating a new sample
						$hash{$id}{$sample}{'SPANJ'} = $spanJ;
						$hash{$id}{$sample}{'SPANPE'} = $spanPE;
						$hash{$id}{$sample}{'COVER'} = ($spanPE + $spanJ);
						$hash{$id}{$sample}{'SCORE'} = $score;
						$hash{$id}{'SUM_SCORE'} += $score;	# chimValues sum : in the final table the mean is reported
						$hash{$id}{'COUNT'}++;	# number of recurent chimera incremented
						if (!defined $hash{$id}{'SAMPLES'}) { # impossible ?
							$hash{$id}{'SAMPLES'} = "$sample";
						}else{
							$hash{$id}{'SAMPLES'} .= ",$sample";	# incrementing sample list with the 'new' sample
							#$total_redund_chim++;	# total number of redundant chimeras
						}
					}
				}
				if (defined $comments){
					my @comments_tmp = split(/,/,$comments);
					foreach my $comment (@comments_tmp){
						$hash{$id}{'COMMENTS'}{$comment}++;	# save each part of the comment and number
					}
				}
			}
		}
	} # end while nb2 (line reading)
	$new_sample = 0;
    close(IN);
}	# end while nb1 (sample reading)

print "Filtering chimeras...\n";

# Chimeras filtering

foreach my $key (keys %hash){	# hash table = all chimeras
	my $name = $hash{$key}{'NAME'};
	my $deleted = 0;
	# select chimIds with redundancy >= min_redundant
    if ($hash{$key}{'COUNT'} >= $min_redundant) {
		# computing the average score and building comments column
		my $total = $hash{$key}{'COUNT'};
    	my $sum_score = $hash{$key}{'SUM_SCORE'};
    	my $mean_score = int($sum_score/$total + 0.5);
    	$hash{$key}{'MEAN_SCORE'} = $mean_score;
    	foreach my $key2 (keys %{ $hash{$key}{'COMMENTS'} }) {	# key2 for the sub hash table 'comments' : save comment + nb occurences of the comment into $key2
			if (!defined $hash{$key}{'COMMENTS'}{'TOTAL'}){	# if total not defined : create total and give the comment as name + save nb occurences
				$hash{$key}{'COMMENTS'}{'TOTAL'} = $hash{$key}{'COMMENTS'}{$key2}."x".$key2;
			}else{
				$hash{$key}{'COMMENTS'}{'TOTAL'} .= ",".$hash{$key}{'COMMENTS'}{$key2}."x".$key2;
			}
		}
		if (!defined $hash{$key}{'COMMENTS'}{'TOTAL'}){
			$hash{$key}{'COMMENTS'}{'TOTAL'} = "NA";
		}
		if (!defined $hash{$key}{'SUBCLASS'}){
			$hash{$key}{'SUBCLASS'} = "NA";
		}
		# delete elements corresponding to HLA genes (?)
		my @names = split(/---/,$hash{$key}{'NAME'});
		foreach my $gene_name (@names){
			if ($gene_name =~ m/^HLA/){
				delete $hash{$key};
				$deleted ++; # useful ??
				last;
			}
		}
		next if ($deleted >= 1);
		# delete elements corresponding to N/A---N/A genes
		if ("$name" eq "N/A---N/A"){
			delete $hash{$key};
			next;
		}
		# delete elements with small scores/rank (chimValue)
		if ($hash{$key}{'MEAN_SCORE'} < $min_score){
			delete $hash{$key};
			next;
		}
		# delete chimIds with cover >3000 (superfamily genes)
		if (defined $hash{$key}{'SAMPLES'}){
			my @samples = split(/,/,$hash{$key}{'SAMPLES'});
			foreach my $sample (@samples){
				if ((defined $max_cover) && ($hash{$key}{$sample}{'COVER'} > $max_cover)){
					delete $hash{$key};
					$deleted++;
					last;
				}
			}
			next if ($deleted >= 1);
		}
		# delete elements with high redundancy
		if ((defined $max_redundant) && ($hash{$key}{'COUNT'} > $max_redundant)){
			delete $hash{$key};
			next;
		}else{	# store features by sample
			my $class = $hash{$key}{'CLASS'};
			my $name = $hash{$key}{'NAME'};
			my @samples = split(/,/,$hash{$key}{'SAMPLES'});
			foreach my $sample (@samples){
				if ((defined $hashsample{$sample}) && (defined $hashsample{$sample}{'REDUND_CHIMERA'}{$class})){
					$hashsample{$sample}{'REDUND_CHIMERA'}{$class} .= ",$name";
				}else{
					$hashsample{$sample}{'REDUND_CHIMERA'}{$class} = "$name";
				}
				$hashsample{$sample}{'REDUND_CHIMERA'}{'COUNTS'}{$class}++;
				$hashsample{$sample}{'REDUND_CHIMERA'}{'COUNTS'}{'TOTAL'}++;
			}
		}
		# delete the element not enough redundant
	}else{
		delete $hash{$key};
	}
}

print "Printing results in output files...\n";

# print results

# ------------------------------ format data for output ------------------------------

my $output = CracTools::Output->new(file => $output_file);
$output->printHeaders(args => \@ARGV);
$output->printHeaderLine("Goal: cross common chimeras in $nb_sample different samples");
$output->printHeaderLine();
$output->printHeaderLine("Id\tname\tsamples\tclass\tsubclass\tmean_score\tredundancy\tcomments\tread_seq\tpos_junction\tprofil_support\tprofil_location\n");
foreach my $key (keys %hash) { #(sort { $hash{$b}{'SCORE'} <=> $hash{$a}{'SCORE'} || $hash{$a}{'CLASS'} <=> $hash{$b}{'CLASS'} || $hash{$b}{'COUNT'} <=> $hash{$a}{'COUNT'} } keys %hash)
	my $name = $hash{$key}{'NAME'};
	my $samples = $hash{$key}{'SAMPLES'};
	my $class = $hash{$key}{'CLASS'};
	my $subclass = $hash{$key}{'SUBCLASS'};
	my $mean_score = $hash{$key}{'MEAN_SCORE'};
	my $count = $hash{$key}{'COUNT'};
	my $comments = $hash{$key}{'COMMENTS'}{'TOTAL'};
	my $read_seq = $hash{$key}{'READ'};
   	my $pos_junction = $hash{$key}{'POS_JUNCTION'};
 	my $profil_support = $hash{$key}{'PSUP'};
  	my $profil_location = $hash{$key}{'PLOC'};
	$output->printLine($key,$name,$samples,$class,$subclass,$mean_score,$count,$comments,$read_seq,$pos_junction,$profil_support,$profil_location);
 }

# ------------------------------ format data for R ------------------------------

if (defined $r_file){
    open(R,">$r_file") or die("enable to open $r_file");
    print R "# Format data for heatmap graphics\n";
    print R "Id\tName\tSample\tSpanJ\tSpanPE\tChim_Cover\tChim_score\tChim_mean_score\tClass\tSubclass\tComments\tSample_cover\tSamples\n";
    foreach my $key (keys %hash) {
		my $samples = $hash{$key}{'SAMPLES'};
	    my @samples = split(/,/,$hash{$key}{'SAMPLES'});
	    my $name = $hash{$key}{'NAME'};
	    my $class = $hash{$key}{'CLASS'};
	    my $subclass = $hash{$key}{'SUBCLASS'};
	    my ($comments) = $hash{$key}{'COMMENTS'}{'TOTAL'};
	    foreach my $sample (@samples){
			my $spanJ = $hash{$key}{$sample}{'SPANJ'};
			my $spanPE = $hash{$key}{$sample}{'SPANPE'};
			my $cover = $hash{$key}{$sample}{'COVER'};
			my $score = $hash{$key}{$sample}{'SCORE'};
			my $mean_score = $hash{$key}{'MEAN_SCORE'};
			my $sample_cover = $hashsample{$sample}{'SAMPLE_COUNTS'}{'SAMPLE_READS'};
			print R "$key\t$name\t$sample\t$spanJ\t$spanPE\t$cover\t$score\t$mean_score\t$class\t$subclass\t$comments\t$sample_cover\t$samples\n";
		}
    }
    close(R);
}

# ------------------------------ SUMMARY ------------------------------

if (defined $summary_file){
	my $total_chimeras = 0;
    foreach my $key (keys %hashsample) {
		$total_chimeras = int($total_chimeras + $hashsample{$key}{'SAMPLE_COUNTS'}{'SAMPLE_CHIMERA'});
    }
    my $total_retained_chimeras = $total_chimeras - ($nb_low_spanj + $nb_filtered_chim + $nb_commented_chim); # remove all chimeras that didn't pass thresholds
    my $total_retained_chimIds = 0;
    my %hash_stats;
    foreach my $key (keys %hash) {
	    $total_retained_chimIds++;
	    my $redundancy = $hash{$key}{'COUNT'}; # redundancy of each chimera (*2, *3...)
	    my $mean_score = $hash{$key}{'MEAN_SCORE'};
	    my $class = $hash{$key}{'CLASS'};
	  	$hash_stats{'MEAN_SCORE'}{$mean_score}++;
	    $hash_stats{'CLASS'}{$class}++;
    	if (defined $hash_stats{'REDUND_CLASS'}{$redundancy}){
			$hash_stats{'REDUND_CLASS'}{$redundancy} .=",$class";
	    }else{
			$hash_stats{'REDUND_CLASS'}{$redundancy} .="$class";
	    }
	    $hash_stats{'REDUNDANT'}{$redundancy}++;
    }
    my $total_deleted_chimIds = $total_chimIds - $total_retained_chimIds;
    if (!defined $max_redundant){
		$max_redundant = $nb_sample;
    }
    if (!defined $filter_file){
		$filter_file = 0;
    }
    if (!defined $max_cover){
		$max_cover = "not defined";
    }
    open(OUT, ">$summary_file") or die("enable to open $summary_file");
    print OUT "# $total_chimeras chimeras are found in $nb_sample different samples\n";
    print OUT "# $nb_low_spanj chimeras are deleted because of raw spanj < $absSpanJ_thr\n";
    print OUT "# $nb_filtered_chim chimeras are filtered out ($filter chimeras in $filter_file filter file)\n";
    print OUT "# $nb_commented_chim chimeras are filtered out due to stringency test, GSNAP or other test results (comments)\n";
    print OUT "# Out of $total_retained_chimeras retained chimeras, $total_chimIds correspond to different chimeras (chimIds)\n";
    print OUT "# $total_deleted_chimIds chimIds are deleted because of a rank < $min_score, a minimal redundancy < $min_redundant, a max redundancy > $max_redundant, a cover < $min_cover and > $max_cover, or because of N/A---N/A gene names\n";
    print OUT "# At the end, $total_retained_chimIds redundant (>= $min_redundant) and unique chimeras (chimIds) are retained\n";
    print OUT "# Date: ".localtime()."\n\n";
    print OUT "# Statistics by rank:\n";
    print OUT "#rank\tnumber\n";
    foreach my $elt (sort {$hash_stats{'MEAN_SCORE'}{$b} <=> $hash_stats{'MEAN_SCORE'}{$a}} keys %{ $hash_stats{'MEAN_SCORE'}}){
	    print OUT "$elt\t".$hash_stats{'MEAN_SCORE'}{$elt}."\n";
    }
    print OUT "\n";
    print OUT "# Statistics by class:\n";
    print OUT "#class\tnumber\n";
    foreach my $elt (sort {$hash_stats{'CLASS'}{$b} <=> $hash_stats{'CLASS'}{$a}} keys %{ $hash_stats{'CLASS'}}){
	    print OUT "$elt\t".$hash_stats{'CLASS'}{$elt}."\n";
    }
    print OUT "\n";
    print OUT "# Statistics by nb_redundant chimeras:\n";
    print OUT "#redundancy\tnumber\tlist_of_different_classes\n";
    foreach my $elt (sort {$hash_stats{'REDUNDANT'}{$b} <=> $hash_stats{'REDUNDANT'}{$a}} keys %{ $hash_stats{'REDUNDANT'}}){
	    if ($hash_stats{'REDUNDANT'}{$elt} < MAX_PRINT_REDUNDANCY){
			print OUT "$elt\t".$hash_stats{'REDUNDANT'}{$elt}."\t".$hash_stats{'REDUND_CLASS'}{$elt}."\n";
	    }else{
			my @redunclass = split(/,/,$hash_stats{'REDUND_CLASS'}{$elt});
			print OUT "$elt\t".$hash_stats{'REDUNDANT'}{$elt}."\t".join(",", @redunclass[0..MAX_PRINT_REDUNDANCY-1]).",...//\n";
	    }
    }
    print OUT "\n";
    print OUT "# Statistics by sample:\n";
    print OUT "#sample\tnumber_reads\tnumber_chimeras\tnumber_spanJ\tnumber_spanPE\tnumber_redundant_chimeras\n";
    foreach my $elt (keys %hashsample){
	    my $total = defined $hashsample{$elt}{'REDUND_CHIMERA'}{'COUNTS'}{'TOTAL'} ? $hashsample{$elt}{'REDUND_CHIMERA'}{'COUNTS'}{'TOTAL'} : 0;
	    print OUT "$elt\t".$hashsample{$elt}{'SAMPLE_COUNTS'}{'SAMPLE_READS'}."\t".$hashsample{$elt}{'SAMPLE_COUNTS'}{'SAMPLE_CHIMERA'}."\t".$hashsample{$elt}{'SAMPLE_COUNTS'}{'SAMPLE_SPANJ'}."\t".$hashsample{$elt}{'SAMPLE_COUNTS'}{'SAMPLE_SPANPE'}."\t".$total."\n";
    }
    print OUT "\n";
    print OUT "# Statistics by sample and by class:\n";
    print OUT "#sample\tclass\tnumber\tlist_of_different_chimeras\n";
    foreach my $elt (keys %hashsample){
	    print OUT "$elt\n";
	    for (my $i=1 ; $i <= 4 ; $i++){
			if (defined $hashsample{$elt}{'REDUND_CHIMERA'}{'COUNTS'}{$i}){
				if ($hashsample{$elt}{'REDUND_CHIMERA'}{'COUNTS'}{$i} < MAX_PRINT_NAME){
					print OUT "\t".$i."\t".$hashsample{$elt}{'REDUND_CHIMERA'}{'COUNTS'}{$i}."\t".$hashsample{$elt}{'REDUND_CHIMERA'}{$i}."\n";
				}else{
					my @chim = split(/,/,$hashsample{$elt}{'REDUND_CHIMERA'}{$i});
					print OUT "\t".$i."\t".$hashsample{$elt}{'REDUND_CHIMERA'}{'COUNTS'}{$i}."\t".join(",", @chim[0..MAX_PRINT_NAME-1]).",...//\n";
				}
			}else{
				print OUT "\t".$i."\t".NA."\t".NA."\n";
			}
		}
    }
    print OUT "\n";
    close(OUT);
}
